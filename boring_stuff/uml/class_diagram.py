#!/usr/bin/env python
import time
"""A CONNECTION B

Types
    AGGREGATION
    COMPOSITION
    EXTENSION: B extends A

"""
CONNECTION = {
    "EXTENSION":" <|-down- ",
    "COMPOSITION": " *-down- ",
    "AGGREGRATION": " o-down- ",
}
ACCESS = {
    "PRIVATE":"-",
    "PROTECTED":"#",
    "PUBLIC":"+",
}
MODIFIERS = {
    "ABSTRACT":"{abstrac}",
    "STATIC":"{static}",
}

def creator_note(out_file):
    """Add note to WSD file

    Add a note that this is autogenerated by py-boring-stuff
    and add a timestamp.

    Parameters
    ----------
    out_file : output file
        WSD file to write.
    """
    # add a detacted note with the info
    out_file.write("note as autonote\n")
    out_file.write("Autogenerated by py-boring-stuff\n")
    out_file.write("%s\n"%time.ctime())
    out_file.write("end note\n\n")

def write_class_diagram(module, output="/tmp/gen.wsd"):
    """Write a class diagram

    Draw the class diagram provided the description from
    class_list

    Parameters
    ----------
    class_list : list
        List of class specification in dictionary format.
        Expected fields are
            type: class
            name: $NAME
            attributes: list of attributes
            methods: list of methods

    output : str
        The output file path for the WSD file.
    """
    with open(output, "w") as file_out:
        # -------------------  initialize variables  ------------------------

        def write_class(class_spec):
            file_out.write("\nclass %s {\n"%class_spec.get("name"))
            for method in class_spec.get("methods", []):
                param_str = ", ".join(method.get("params",[]))

                file_out.write(" "*4 + "{} {} {}({})\n".format(
                    ACCESS[method.get("access").upper()],
                    "void", method.get("name"), param_str))
            file_out.write("}\n") # write complete class

        # -------------------  write WSD UML file  --------------------------
        # initialize UML
        file_out.write("@startuml\n")

        # add a note
        creator_note(file_out)

        # encompass class with module
        module_name = str(module.get("name", "module_name"))
        file_out.write("package %s {\n"%module_name )

        class_list = module.get("class_list", [])
        if not class_list:
            class_spec = {
                "type":"class",
                "name":module.get("name") + "DEFAULT",
                "methods": module.get("methods"),
            }
            class_list = [class_spec]

        # ------------------  write classes  ----------------------------
        list_ext = []
        for class_spec in class_list:
            write_class(class_spec)

            # check parent and perhap update list_ext
            parent = class_spec.get("parent")
            if parent:
                list_ext.append("{}{}{}".format(
                    parent,
                    CONNECTION.get("EXTENSION"),
                    class_spec.get("name")))

        # draw links between extensions
        for ext in list_ext:
            file_out.write(ext + "\n")

        # -------------------  finalize uml  ----------------------------
        # end package
        file_out.write("}\n")

        # finalize UML
        file_out.write("@enduml\n")